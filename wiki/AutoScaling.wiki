NOTE: На этой странице будут материалы по автомасштабированию

Введение в предметную область
Облачный сервис  предоставляет возможность разработки и выполнения приложений и хранения данных на серверах, расположенных в распределенных датацентрах. Клиент оплачивает только ресурсы и мощности, которые задействованы в приложение и только за фактическое время использования этих ресурсов. В основе работы Windows Azure лежит запуск виртуальной машины для каждого экземпляра приложения. Разработчик определяет необходимый объем для хранения данных и требуемые вычислительные мощности (количество виртуальных машин), после чего платформа предоставляет соответствующие ресурсы. Когда первоначальные потребности в ресурсах изменяются, в соответствии с новым запросом заказчика платформа выделяет под приложение дополнительные или сокращает неиспользуемые ресурсы датацентра.

Постановка задачи
Для нормального функционирования сервиса требуется, чтобы его мощности всегда могли справляться с нагрузкой на него. Но моментально среагировать на скачок нагрузки невозможно, виртуальная машина подключается некоторое время (до часа). Если сервер будет тормозить в течение часа, он может потерять популярность. Поэтому надо научить приложение предугадывать пики нагрузки и подключать новые ресурсы заранее. Причем ошибки в предугадывании также могут сильно сказаться на доходах, поскольку содержание вычислительных ресурсов стоит денег и не хотелось бы, чтобы они работали вхолостую. Также существует «реактивный» способ реагирования. В этом случае новые машины подключаются, если нагрузка превысила некоторый процент.
Таким образом, была поставлена задача:
написать анализатор нагрузки, который, основываясь на полученных ранее статистических данных, сможет заранее подключать новые машины
найти оптимальный процент, при котором следует подключать новые ресурсы и реализовать этот «реактивный» способ реагирования
найти баланс между описанными выше способами и за счет этого добиться максимального сокращения эксплуатационных затрат при поддерживании максимальной производительности 

Что уже сделано
Я ознакомился с предметной областью по теме моей курсовой работы. Также я узнал о существовании библиотеки Microsoft Enterprise Library Autoscaling Application Block (WASABi), которая позволяет добавлять автоматическое масштабирование в Windows Azure




Функциональный блок для автоматического масштабирования (Autoscaling Application Block) из библиотеки Enterprise Library предоставляет инструмент, 
который вы можете интегрировать непосредственно в веб- и рабочие роли, работающие в облаке, а также в локальные приложения. Данный компонент является 
частью пакета интеграции Microsoft Enterprise Library 5.0 для Windows Azure и может автоматически масштабировать приложение Windows Azure или работать 
на основе правил, определяемых вами специально для приложения или службы. Вы можете использовать эти правила, чтобы обеспечить своему приложению или 
службе необходимую пропускную способность в ответ на изменение рабочей нагрузки и в то же время минимизировать и контролировать расходы на размещение. 
Данный функциональный блок позволяет облачному приложению запускать и останавливать экземпляры роли, изменять настройки конфигурации, чтобы регулировать 
функциональность приложения и сократить использование ресурсов, а также отправлять уведомления в соответствии с определенным графиком.

Пример 1
Чтобы предусмотреть большинство моментов падений и повышений нагрузки, компания решила внедрить функциональный блок для автомастштабирования следующим 
образом:

* Разработчики настроили правила ограничения для приложения с целью запуска трех дополнительных экземпляров веб- и рабочих ролей в каждом центре данных
 в 15:15 по центральному поясному времени (новые экземпляры становятся доступны в течение 10 или 15 минут) и для остановки этих экземпляров в 20:30 с 
понедельника по четверг.

* В 17:15 приложение запускает еще два экземпляра каждой роли, которые прекращают работу в 18:30.

* По пятницам время дополнительных запусков и остановок сдвигается на два часа раньше.

* Чтобы справиться с неожиданно возрастающей нагрузкой, компания Trey Research также настроила правила реагирования для контроля количества запросов 
клиентов таким образом, чтобы запускать дополнительные экземпляры, если средняя загрузка процессора для веб-роли превышает 85 % в течение 10 минут и 
более, максимум до 12 экземпляров в каждом центре данных. Когда загрузка процессора падает ниже 50 %, экземпляры прекращают работать, оставляя не более 
двух экземпляров в каждом центре данных.

* В выходные дни система ограничивается четырьмя экземплярами каждой роли в каждом центре данных, и любые дополнительные экземпляры, превышающие это 
количество, прекращают работать, чтобы снизить эксплуатационные расходы.

* Когда система находится в неактивном состоянии или слегка загружена, она возвращается к своей базовой конфигурации, состоящей из двух экземпляров 
каждой роли в каждом центре данных.

Функциональный блок для автоматического масштабирования контролирует производительность одной или нескольких ролей, запуск и остановку ролей, применение регулирующих изменений конфигурации или отправку уведомлений, как указано в различных ограничивающих правилах и правилах реагирования. Функциональный блок для автоматического масштабирования также генерирует диагностическую информацию и фиксирует точки данных, указывая выполненную работу.
Для выполнения этой задачи функциональный блок для автоматического масштабирования использует объект Autoscaler (определенный в пространстве имен
Microsoft.Practices.EnterpriseLibrary.WindowsAzure.Autoscaling), и вы должны подготовить этот объект
для запуска во время работы своего приложения. Предложеное решение выполняет эту задачу в методе Run класса WorkerRole (в проекте Orders.Workers), а останавливает объект Autoscaler в методе OnStop:

public class WorkerRole :RoleEntryPoint
{
	private Autoscalerautoscaler;
	...
	public override void Run()
	{
		this.autoscaler = EnterpriseLibraryContainer.Current.
		GetInstance<Autoscaler>();
		this.autoscaler.Start();
		...
	}
	...
	public override void OnStop()
	{
		this.autoscaler.Stop();
		...
	}
	...
}



Наше решение реализует комбинацию правил ограничения и реагирования. Ограничивающие правила задают расписание, используемое объектом Autoscaler, 
в дополнение к максимальному и минимальному количеству экземпляров ролей в течение каждого запланированного периода. Объект AutoScaler инициирует создание экземпляров веб- и рабочих ролей или останавливает существующие экземпляры, когда расписание изменяет границы и количество экземпляров превышает новые границы. Правила реагирования запускают дополнительные экземпляры веб-ролей или останавливают их,
в зависимости от загрузки процессора веб-роли. В качестве начальной отправной точкой в нашем решении определен следующий набор правил:
{{{
<?xmlversion="1.0" encoding="utf-8" ?>
<rules xmlns="http://schemas.microsoft.com/practices/2011/entlib/autoscaling/rules">

	<constraintRules>
		<rule name="Weekday" enabled="true" rank="10">
			<timetablestartTime="00:00:00" duration="23:59:59" utcOffset="-06:00">
				<weekly days= "Monday Tuesday Wednesday Thursday Friday"/>
			</timetable>
			<actions>
				<rangetarget="Orders.Workers" min="2" max="12"/>
				<rangetarget="Orders.Website" min="2" max="12"/>
			</actions>
		</rule>

		<rule name="Weekend" enabled="true" rank="10">
			<timetablestartTime="00:00:00" duration="23:59:59" utcOffset="-06:00">
				<weekly days="SundaySaturday"/>
			</timetable>
			<actions>
				<rangetarget="Orders.Workers" min="2" max="4"/>
				<rangetarget="Orders.Website" min="2" max="4"/>
			</actions>
		</rule>

		<rule name="MondayToThursday" enabled="true" rank="2">
			<timetablestartTime="15:15:00" duration="05:15:00" utcOffset="-06:00">
				<weekly days="Monday Tuesday Wednesday Thursday"/>
			</timetable>
			<actions>
				<rangetarget=" Orders.Workers" min="4" max="12"/>
				<rangetarget=" Orders.Website" min="4" max="12"/>
			</actions>
		</rule>

		<rule name="MondayToThursdayPeak" enabled="true" rank="3">
			<timetablestartTime="17:15:00" duration="03:15:00" utcOffset="-06:00">
				<weekly days="Monday Tuesday Wednesday Thursday"/>
			</timetable>
			<actions>
				<rangetarget=" Orders.Workers" min="6" max="12"/>
				<rangetarget=" Orders.Website" min="6" max="12"/>
			</actions>
		</rule>

		<rule name="Friday" enabled="true" rank="2">
			<timetablestartTime="13:15:00" duration="05:15:00" utcOffset="-06:00">
				<weekly days="Friday"/>
			</timetable>
			<actions>
				<rangetarget=" Orders.Workers" min="6" max="12"/>
				<rangetarget=" Orders.Website" min="6" max="12"/>
			</actions>
		</rule>

		<rule name="FridayPeak" enabled="true" rank="3">
			<timetablestartTime="15:15:00" duration="03:15:00" utcOffset="-06:00">
				<weekly days="Friday"/>
			</timetable>
			<actions>
				<rangetarget=" Orders.Workers" min="7" max="12"/>
				<rangetarget=" Orders.Website" min="7" max="12"/>
			</actions>
		</rule>
	</constraintRules>

	<reactiveRules>
		<rule name="HotCPU" enabled="true" rank="4">
			<when>
				<greateroperand="CPU" than="85" />
			</when>
			<actions>
				<scaletarget="Orders.Website" by ="1"/>
			</actions>
		</rule>

		<rule name="CoolCPU" enabled="true" rank="4">
			<when>
				<lessoperand="CPU" than="50" />
			</when>
			<actions>
				<scaletarget="Orders.Website" by ="-1"/>
			</actions>
		</rule>
	</reactiveRules>

	<operands>
		<performanceCounteralias="CPU" source="AccidentReporting_WebRole" performanceCounterName= "\Processor(_Total)\% Processor Time" timespan="00:10:00" aggregate="Average"/>
	</operands>
</rules>
}}}
Правила были загружены в хранилище BLOB-объектов и сохранены в BLOB-объекте, который описан в секции <rulesStores> файла app.config для рабочей роли.
Операнд CPU, участвующий в правилах реагирования, рассчитывает среднюю загрузку процессора за 30-минутный период, используя счетчик производительности 
\Processor(_Total)\% Processor Time. Для сбора этой информации веб-роль Orders.Website была изменена с помощью следующего кода, выделенного жирным 
шрифтом в методе StartDiagnostics (вызывается из метода OnStart) в файле
WebRole.cs:
{{{
public class WebRole :RoleEntryPoint
{
	...
	private static void StartDiagnostics()
	{
		var config = DiagnosticMonitor.GetDefaultInitialConfiguration();
		...
		config.PerformanceCounters.ScheduledTranferPeriod = Timespan.FromMinutes(10);
		config.PerformanceCounters.DataSources.Add(
			new PerformanceCounterConfiguration
			{
				CounterSpecifier =
				@"\Processor(_Total)\% Processor Time",
				SampleRate = TimeSpan.FromMinutes(30)
			});
	...
	DiagnosticMonitor.Start(
	"DiagnosticsConnectionString", config);
}
...
}
}}}